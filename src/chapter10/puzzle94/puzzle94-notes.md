# Puzzle 94: Lost in the Shuffle

The following shuffle method purports to shuffle its input array fairly. In other words, 
it purports to generate all permutations with equal likelihood, assuming that the underlying pseudorandom 
number generator is fair. Does it make good on its promise? If not, how do you fix it?


Looking at the shuffle method, there's nothing obviously wrong with it. 
It iterates through the array, swapping a randomly chosen element from the array into each location. 
That ought to shuffle the array fairly, right? Wrong. There's a big difference between saying 
"There's nothing obviously wrong with this code" and "There's obviously nothing wrong with this code." 
In this case, there's something very wrong, but it isn't obvious unless you specialize in algorithms.

If you call the shuffle method on an array of length n, the loop iterates n times. 
In each iteration, the method chooses one of the n integers between 0 and n - 1. 
Therefore, there are nn possible executions of the method. We assumed the random number generator is fair, 
so each execution occurs with equal likelihood. Each execution generates one permutation of the array. 
There is, however, one small problem: There are n! distinct permutations of an array of length n. 
(The exclamation point after n indicates the factorial operation: n factorial is defined as n x (n - 1) x (n - 2) x ...x 1.)
The problem is that n^n is not divisible by n! for any n greater than 2, because n! has every prime factor from 2 through n, 
but n^n has only the prime factors that make up n. 
This proves beyond a shadow of a doubt that the shuffle method generates some permutations more often than others.


To make this concrete, let's consider an array of length 3 containing the strings "a", "b", and "c". 
There are 3^3 = 27 possible executions of the shuffle method. 
All are equally likely, and each generates some permutation. 
There are 3! = 6 distinct permutations of the array: 
{"a", "b", "c"}, {"a", "c", "b"}, {"b", "a", "c"}, {"b", "c", "a"}, {"c", "a", "b"}, and {"c", "b", "a"}. 
Because 27 is not divisible by 6, some of these permutations 
must be generated by more executions than others, so the shuffle method is not fair.


One problem with this proof is that it offers no intuition into the bias induced by the method; 
it merely proves that a bias exists. Often the best way to gain some insight is to perform an experiment. 
We ran a program that calculates the expected value of the element at each position when the method is 
run on the "identity array," where a[i] = i. Loosely speaking, the expected value is the average value that you'll see
in the element if you run the shuffle method repeatedly. If the shuffle method were fair, 
the expected value would be the same for each element: ((n -1 ) / 2). 

Figure 10.1 shows the expected value for each element in an array of length 9. 
Note the distinctive shape of the graph:
It starts low, increases beyond the fair value (4), and settles down to the fair value in the last element.


Why does the graph have this shape? We don't know all the details but we can offer some intuition. 
Let's restrict our attention to the array's first element. 
After the first iteration of the loop, it has the correct expected value of (n - 1) / 2. 
In the second iteration, however, there is 1 chance in n that the random number generator will return 0 and 
the value in the first element will be replaced by 1 or 0. In other words, the second iteration systematically 
reduces the expected value of the first element. In the third iteration, there's a further 1 chance in n that 
the first element is replaced by 2, 1, or 0, and so on. For the first n / 2 iterations of the loop, 
the expected value of the first element decreases. For the second n / 2 iterations, it increases but never catches up 
to its fair value. Note that the last element in the array is guaranteed to have the correct expected value, 
as the last step in the execution of the method is to select it at random from all the elements in the array.

OK, so our shuffle method is broken. How do we fix it? Use the shuffle method provided by the library:

<pre>
import java.util.*;
public class Shuffle {
    
      public static void shuffle(Object[] a) {
            Collections.shuffle(Arrays.asList(a));
      } 

}

</pre>


On the other hand, after you suffered through all that math, it seems unfair not to tell you how to fix 
the broken shuffle method. The fix is actually quite straightforward. 
In the body of the loop, swap the current element with an element selected at random from the
portion of the array starting at the current element and extending to the end of the array. 
Do not touch an element once you've swapped a value into it. 
This is essentially the algorithm that is used by the library method:

<pre>
    public static void shuffle(Object[] a) {
        for (int i = 0; i < a.length; i++)
            swap(a, i, i + rnd.nextInt(a.length - i));
    }
</pre>



In summary, shuffling an array, like many algorithms, is tricky. It's easy to get it wrong and hard to tell that you did. 
All other things being equal, you should use trusted libraries in preference to handwritten code. 
If you want to learn more about the issues discussed in this puzzle, see [Knuth98 3.4.2].
